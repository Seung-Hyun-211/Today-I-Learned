# [빛의 경로 사이클](https://school.programmers.co.kr/learn/courses/30/lessons/86052)


### Solution

low * cal * 4 ( 상, 우, 하, 좌 ) 크기의 ```visit``` 생성<br>
grid[i][j]에 따라 방향(```dir```)을 전환하며 탐색<br>
grid[i][j][dir] 에서 dir은 해당 방향으로 진행을 했는가 여부 진행 했으면 사이클이 완성


```
vector<int> solution(vector<string> grid) {
    vector<int> answer;

    //3차원 배열
    int row = grid[0].length();
    int col = grid.size();
    bool* data = new bool[row * col * 4];
    memset(data, false, row * col * 4 * sizeof(bool));
    bool*** visit = new bool**[col];
    for (int y = 0; y < col; y++)
    {
        visit[y] = new bool* [row];
        for (int x = 0; x < row; x++)
        {
            visit[y][x] = data + (y * row * 4) + (x * 4);
        }
    }

    // 위,오른,아래,왼

    //dir % 4   = 0,1,2,3 
    //case 'S' -> 방향 유지
    //case 'R' -> idx 증가
    int dirx[4] = { 0,1,0,-1 };
    int diry[4] = { 1,0,-1,0 };

    //case 'L' -> idx 감소
    for (int i = 0; i < col; i++)
    {
        for (int j = 0; j < row; j++)
        {
            for (int l = 0; l < 4; l++)
            {
                if (visit[i][j][l] == false)
                {                    
                    int y = i;
                    int x = j;
                    int dir = l;


                    int count = 0;
                    while (true)
                    {
                        x = (x + row) % row;
                        y = (y + col) % col;
                        dir = (dir+4) % 4;
                        if (visit[y][x][dir] == true)
                        {
                            answer.push_back(count);
                            break;
                        }
                        visit[y][x][dir] = true;
                        count++;
                        switch (grid[y][x])
                        {
                        case 'S':
                            x += (dirx[dir] % row);
                            y += (diry[dir] % col);

                            break;
                        case 'R':
                            dir = (dir + 1) % 4;
                            x += (dirx[dir] % row);
                            y += (diry[dir] % col);
                            break;
                        case 'L':
                            dir = (dir + 3) % 4;
                            x += (dirx[dir] % row);
                            y += (diry[dir] % col);
                            break;
                        }
                    }
                }
            }
        }
    }

    sort(answer.begin(), answer.end());
    return answer;
}
```