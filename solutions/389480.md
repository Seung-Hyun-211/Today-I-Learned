# [완전범죄](https://school.programmers.co.kr/learn/courses/30/lessons/389480)

### 문제 설명
A도둑과 B도둑이 팀을 이루어 모든 물건을 훔치려고 합니다.<br>
단, 각 도둑이 물건을 훔칠 때 남기는 흔적이 누적되면 경찰에 붙잡히기 때문에, 두 도둑 중 누구도 경찰에 붙잡히지 않도록 흔적을 최소화해야 합니다.

물건을 훔칠 때 조건은 아래와 같습니다.

물건 i를 훔칠 때,<br>
A도둑이 훔치면 info[i][0]개의 A에 대한 흔적을 남깁니다.<br>
B도둑이 훔치면 info[i][1]개의 B에 대한 흔적을 남깁니다.<br>
각 물건에 대해 A도둑과 B도둑이 남기는 흔적의 개수는 1 이상 3 이하입니다.

경찰에 붙잡히는 조건은 아래와 같습니다.<br>
A도둑은 자신이 남긴 흔적의 누적 개수가 n개 이상이면 경찰에 붙잡힙니다.<br>
B도둑은 자신이 남긴 흔적의 누적 개수가 m개 이상이면 경찰에 붙잡힙니다.<br><br>
각 물건을 훔칠 때 생기는 흔적에 대한 정보를 담은 2차원 정수 배열 info,<br>
A도둑이 경찰에 붙잡히는 최소 흔적 개수를 나타내는 정수 n,<br>
B도둑이 경찰에 붙잡히는 최소 흔적 개수를 나타내는 정수 m이 매개변수로 주어집니다.<br>
두 도둑 모두 경찰에 붙잡히지 않도록 모든 물건을 훔쳤을 때, A도둑이 남긴 흔적의 누적 개수의 최솟값을 return 하도록 solution 함수를 완성해 주세요.<br>
 만약 어떠한 방법으로도 두 도둑 모두 경찰에 붙잡히지 않게 할 수 없다면 -1을 return해 주세요.


### Solution

1. 재귀<br>
n, m 을 감소시키며 index를 증가시켜 다시 함수를 호출

> 채점 결과<br>
정확성: 40.0<br>
합계: 40.0 / 100.0 (시간초과 60)


```
int func(const vector<vector<int>>& info, int n, int m, int idx)
{
    if (n <= 0 || m <= 0) return -1;

    if (idx == info.size()) return n;

    return max(func(info, n - info[idx][0], m, idx + 1), func(info, n, m - info[idx][1], idx + 1));
}

int solution(vector<vector<int>> info, int n, int m) {
    int result = func(info, n, m, 0);
    return result == -1 ? -1 : n - result;
}
```

1. DP
info의 index와 m 을 크기로 하는 2차원 배열을 생성(최대값으로 초기화)<br>
cache는 info[i]까지 왔을 때 b의 흔적 j와, a의 흔적 cache[i][j]

```
int solution(vector<vector<int>> info, int n, int m) 
{
    int answer = INT16_MAX;
    int len = info.size();

    //cache[i][j] = i -> 정보, j -> B의 흔적 개수
    vector<vector<int>> cache(len, vector<int>(m, INT16_MAX));

    //a가 흔적을 남김
    cache[0][0] = info[0][0];
    
    //b가 흔적을 남김
    if(info[0][1] < m)
        cache[0][info[0][1]] = 0;
    

    for (int i = 1; i < len; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (cache[i - 1][j] != INT16_MAX)
            {
                //a가 흔적을 남김
                cache[i][j] = min(cache[i][j], cache[i - 1][j] + info[i][0]);
                //b가 흔적을 남김
                if (j + info[i][1] < m) 
                    cache[i][j + info[i][1]] = min(cache[i - 1][j], cache[i][j + info[i][1]]);
            }
        }
    }

    for (int i = 0; i < m; i++)
    {
        answer = min(answer, cache[len - 1][i]);
    }

    return answer < n ? answer : -1;
}
```