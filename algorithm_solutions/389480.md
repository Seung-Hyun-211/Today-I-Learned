# [완전범죄](https://school.programmers.co.kr/learn/courses/30/lessons/389480)

### Solution

1. 재귀<br>
n, m 을 감소시키며 index를 증가시켜 다시 함수를 호출

> 채점 결과<br>
정확성: 40.0<br>
합계: 40.0 / 100.0 (시간초과 60)


```
int func(const vector<vector<int>>& info, int n, int m, int idx)
{
    if (n <= 0 || m <= 0) return -1;

    if (idx == info.size()) return n;

    return max(func(info, n - info[idx][0], m, idx + 1), func(info, n, m - info[idx][1], idx + 1));
}

int solution(vector<vector<int>> info, int n, int m) {
    int result = func(info, n, m, 0);
    return result == -1 ? -1 : n - result;
}
```

1. DP
info의 index와 m 을 크기로 하는 2차원 배열을 생성(최대값으로 초기화)<br>
cache는 info[i]까지 왔을 때 b의 흔적 j와, a의 흔적 cache[i][j]

```
int solution(vector<vector<int>> info, int n, int m) 
{
    int answer = INT16_MAX;
    int len = info.size();

    //cache[i][j] = i -> 정보, j -> B의 흔적 개수
    vector<vector<int>> cache(len, vector<int>(m, INT16_MAX));

    //a가 흔적을 남김
    cache[0][0] = info[0][0];
    
    //b가 흔적을 남김
    if(info[0][1] < m)
        cache[0][info[0][1]] = 0;
    

    for (int i = 1; i < len; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (cache[i - 1][j] != INT16_MAX)
            {
                //a가 흔적을 남김
                cache[i][j] = min(cache[i][j], cache[i - 1][j] + info[i][0]);
                //b가 흔적을 남김
                if (j + info[i][1] < m) 
                    cache[i][j + info[i][1]] = min(cache[i - 1][j], cache[i][j + info[i][1]]);
            }
        }
    }

    for (int i = 0; i < m; i++)
    {
        answer = min(answer, cache[len - 1][i]);
    }

    return answer < n ? answer : -1;
}
```